<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Documentation</title>
  <link href="https://unpkg.com/tailwindcss@^1.0/dist/tailwind.min.css" rel="stylesheet" />
  <link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />
  <style>
    html {
      scroll-behavior: smooth;
    }
  </style>
</head>

<body>
  <!-- Navigation begins  -->

  <header class="text-gray-600 body-font">
    <div class="
          container
          mx-auto
          flex flex-wrap
          p-5
          flex-col
          md:flex-row
          items-center
        ">
      <a class="
            flex
            title-font
            font-medium
            items-center
            text-gray-900
            mb-4
            md:mb-0
          " href="https://kdsinghcoder.github.io/Align-it">
        <svg version="1.1" xmlns="http://www.w3.org/2000/svg" width="140" height="90">
          <path fill="#0c7ecf"
            d="M21.786,80.958l17.784-48.048l7.8-0.39l17.316,48.438l6.474,1.482l0,4.68l-22.62,0l0-4.68l7.254-1.482l-2.964-8.658l-20.28,0l-3.042,8.658l7.332,1.482l0,4.68l-21.45,0l0-4.68z M50.724,66.06l-7.878-23.478l-8.19,23.478l16.068,0z M87.0408,87.12l0-4.68l7.8-1.56l0-42.12l-10.14,0l-1.95,7.8l-5.07,0l0-14.04l42.51,0l0,14.04l-5.07,0l-1.95-7.8l-10.14,0l0,42.12l7.8,1.56l0,4.68l-23.79,0z"
            viewBox="0 0 24 24" />
          <path fill="#" d="" />
        </svg>

        <span class="ml-3 text-xl">- > Align-it</span>
      </a>
      <nav class="
            md:ml-auto md:mr-auto
            flex flex-wrap
            items-center
            text-base
            justify-center
          ">
        <a class="mr-5 hover:text-gray-900"></a>
        <a class="mr-5 hover:text-gray-900"></a>
        <a class="mr-5 hover:text-gray-900"></a>
        <a class="mr-5 hover:text-gray-900"></a>
      </nav>
      <a href="../index.html">
        <button class="
              inline-flex
              items-center
              bg-gray-100
              border-0
              py-1
              px-3
              focus:outline-none
              hover:bg-gray-200
              rounded
              text-base
              mt-4
              md:mt-0
            ">
          Home Page
          <svg fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
            class="w-4 h-4 ml-1" viewBox="0 0 24 24">
            <path d="M5 12h14M12 5l7 7-7 7"></path>
          </svg>
        </button>
      </a>
    </div>
  </header>
  <!-- Navigation ends -->

  <!-- Content begins -->

  <div class="container w-full px-5 py-24 mx-auto lg:px-32">
    <div class="flex flex-col w-full mx-auto mb-2 prose text-left prose-md">
      <div class="mb-5 border-b border-gray-200">
        <div class="flex flex-wrap items-baseline -mt-2">
          <h5>22-05-2020</h5>
          <p class="mt-1 ml-2">The Align Library.</p>
        </div>
      </div>
      <div class="aspect-w-16 aspect-h-9 mx-auto my-5">
        <iframe width="640" height="360" src="https://www.youtube.com/embed/LhpGz5--isw" title="YouTube video player"
          frameborder="0"
          allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
          allowfullscreen></iframe>
      </div>
      <h1 class="
            mb-2
            text-4xl
            font-extrabold
            leading-snug
            tracking-tight
            text-gray-800
            md:text-5xl
            text-gray-900
            hover:text-purple-700
          ">
        Sequence Alignment and Needleman-Wunsch's Contribution.
      </h1>
      <p class="mb-4 text-base font-normal text-gray-600">
        Did you know that human DNA and chimp DNA are 98.8% the same? Although
        this number may sound small, humans and chimps are very different when
        we go into our DNA. Out of the roughly three billion base pairs that
        make up our genetic code, 1.2% of them equates to over 35 million
        genetic differences.
      </p>

      <img src="https://miro.medium.com/max/675/0*GqcEBIGyUp0WoJX5.gif" alt="" class="mx-auto" />

      <p class="mb-4 text-base font-normal text-gray-600">
        As a result, modeling how the evolution of chimps led to humans from
        the aspect of genomics is a monumental feat due to the number of
        different possibilities there could be for mutations. Mutations can
        consist of insertions (adding of base pairs), deletions (removing of
        base pairs), and alterations (changing of base pairs). When scaled to
        the billions of base pairs we have, the number becomes astronomical
        for the number of permutations that could’ve changed chimp DNA into
        human DNA.
      </p>

      <img src="https://miro.medium.com/max/2700/0*Khc8G3qcamqWuPZj.jpg" alt="" class="mx-auto" />

      <p class="mb-4 text-base font-normal text-gray-600">
        <b>Sequence alignment</b> has solved this problem by allowing us to
        compare two genetic strands and find the sequence of mutations that
        led from one to the other. The goal of sequence alignment is to find
        homologous/similar sequences in the genome, and then base mutations
        off of the gaps that emerge between these sequences.
      </p>
      <img src="https://miro.medium.com/max/537/0*r_fPoz7mGydNBmbp.png" alt="" class="mx-auto" />
      <p class="mb-4 text-base font-normal text-gray-600">
        Because of the number of different evolutionary events that are
        possible, common sequence alignment algorithms attempt to minimize the
        number of events to explain the differences between two genetic
        sequences. Additionally, they use the heuristic that alterations are
        more common than insertions and deletions are.
      </p>
      <h1 class="
            mb-2
            text-lg
            font-extrabold
            leading-snug
            tracking-tight
            text-gray-800
            md:text-lg
            text-gray-900
            hover:text-purple-700
          ">
        Terminology -
      </h1>
      <img src="https://miro.medium.com/max/576/0*ZlzQHtKYE-gSDk0J.png" alt="" class="mx-auto my-3" />

      <p class="mb-4 text-lg font-normal text-gray-600">
        <b> Sequence alignment:</b> process of comparing two nucleotide
        strands to find the series of mutations that created one from the
        other <br />
        <b>Orthologous:</b> event that leads to two organisms having a copy of
        the same gene (can use to trace back evolutionary roots of organisms)
        <br />
        <b>Paralogous:</b> duplication event within a species (two members of
        the same species have similar genes)<br />
        <b>Global alignment:</b> alignment of every element in the genetic
        strand<br />
        <b>Local alignment:</b> alignment of regions that contain similar
        sequences<br />
        <b>NBAs (non-boring alignments):</b> alignments where gaps are always
        paired with nucleotides (e.g. there isn’t a gap in both of the
        sequences)<br />
        <b>Gap penalty:</b> penalty for creating a gap in one of the
        nucleotide sequences<br />
        <b>Substring:</b> a continuous sequence of characters inside a
        string<br />
        <b>Subsequence:</b> sequence that can be derived from a sequence by
        deleting some elements without changing the order of the remaining
        elements<br />
      </p>
      <p class="mb-4 text-lg font-normal text-gray-600 my-4">
        In addition to accounting for mutations, there are extra
        considerations that must be made for gaps. For instance, biologically,
        the cost of creating a gap is much more expensive than that of
        extending an already created gap. There are a few different gap
        penalties currently used:

        <br />
        <br />
        <b> Linear gap penalty:</b> This uses a fixed cost for all gaps,
        regardless of the current gap length it is extending. <br />
        <b>Affine gap penalty: </b>This imposes a large initial cost for
        opening a gap, but then a small incremental cost for each gap
        extension. <br />
        <b>General gap penalty: </b> This uses a variety of different
        polynomial and linear functions to see which provides the best
        sequence alignment. Note this may drastically affect runtime. <br />
        <b>Frame-aware gap penalty: </b>This tailors the cost function to
        account for disruptions in the coding frame; for instance, changes in
        a certain amino acid can cause phenotypic modifications.
      </p>

      <img src="https://miro.medium.com/max/495/0*eAJjS4yWVmywTM9Q.png" alt="" class="mx-auto" />

      <h1 class="
            mb-2
            text-lg
            font-extrabold
            leading-snug
            tracking-tight
            text-gray-800
            md:text-lg
            text-gray-900
            hover:text-purple-700
          ">
        Longest Common Substring (Quadratic) -
      </h1>
      <p class="mb-4 text-base font-normal text-gray-600">
        The most simplistic method to find the number of mutations between two
        genetic sequences is to use the longest common substring between the
        two sequences. Then, you can put the substrings side-by-side in the
        two sequences, and explain the other nucleotides that are offset by
        insertions/alterations. However, this is clearly not the best
        solution, and it also runs very slowly, since you have to enumerate
        all possible alignments.

        <img src="https://miro.medium.com/max/601/1*7hzOZxZvFi9354getRQ-Sg.png" class="mx-auto" />
      </p>

      <p class="mb-4 text-base font-normal text-gray-600">
        As seen in the example above, 6 mutations have been shown to be found
        in between S1 and S2, even though that is clearly not the most optimal
        solution and doesn’t minimize the number of steps between the two
        sequences.
      </p>
      <h1 class="
            mb-2
            text-lg
            font-extrabold
            leading-snug
            tracking-tight
            text-gray-800
            md:text-lg
            text-gray-900
            hover:text-purple-700
          ">
        Longest Common Subsequence (Exponential) -
      </h1>
      <p class="mb-4 text-base font-normal text-gray-600">
        One method to minimize the steps involves allowing gaps between
        subsequences and not just limiting it to substrings. Then, these
        substring parts can be aligned together, and mutations can be found in
        the gaps.
      </p>
      <img src="https://miro.medium.com/max/574/1*Ci0VaCMviiOLOU4M3-8LJQ.png" alt="" class="mx-auto my-4" />
      <p class="mb-4 text-base font-normal text-gray-600">
        As seen in the example above, the mutations have been reduced from 6
        mutations to 4, which means that our algorithm is getting better.
        However, the time complexity has greatly increased, from quadratic to
        exponential.
        <br />
        <br />
        If considering NBAs (where gaps are always paired with nucleotides),
        and with sequences of length n and m where n > m, the number of
        alignments comes out to be (n+m) choose m, which is approximately 2^n
        alignments.
      </p>

      <h1 class="
          mb-2
          text-lg
          font-extrabold
          leading-snug
          tracking-tight
          text-gray-800
          md:text-lg
          text-gray-900
          hover:text-purple-700
        ">
        Dynamic Programming -
      </h1>

      <img src="https://miro.medium.com/max/2700/0*XZBOkj0v2hFtMY2w.png" class="mx-auto my-4">

      <p class="mb-4 text-base font-normal text-gray-600">
        How can we reduce the runtime from exponential to quadratic once more while maintaining the same level of
        accuracy? The answer lies in dynamic programming, which allows us to utilize overlapping subproblems to solve a
        problem efficiently. For a dynamic programming problem, there are two major things to check for:
        <br>
        <br>
        <b> Optimal Substructure:</b> The optimal solution to a problem contains optimal solutions to subproblems of the
        problem.
        <br>
        <br>
        <b> Overlapping Subproblems:</b> Subproblems are repeated many times, so storing the answers to these
        subproblems will reduce computational complexity when running the model.
        <br>
      </p>
      <img src="https://miro.medium.com/max/2700/0*2kJd5RpMC0E204mc.png" class="mx-auto my-4">
      <h1 class="
      mb-2
      text-lg
      font-extrabold
      leading-snug
      tracking-tight
      text-gray-800
      md:text-lg
      text-gray-900
      hover:text-purple-700
    ">
        Needleman-Wunsch Algorithm -
      </h1>
      <p class="mb-4 text-base font-normal text-gray-600">
        We now return back to the problem of the longest common subsequence between two sequences and how to reduce the
        time complexity from exponential to linear. Before doing, this a few variables need to be defined:
      <pre class="text-lg my-5">
      S = {S1, S2, …, Sm} and T = {T1, T2, … Tn}: the two sequences
      d: the gap penalty cost (as explained above)
      s(x; y): the score of aligning a base x from S and a base y from T
      F: matrix where F (x, y) refers to the xth place in S and the yth place in T
    </pre>
      </p>
      <img src="https://miro.medium.com/max/595/0*daaOOSeg8q5785CT.gif" class="mx-auto my-3">
      <p class="mb-4 text-base font-normal text-gray-600">
        This algorithm attempts to use a key part of dynamic programming: that you can keep track of the optimized
        sub-problems to solve the problem of finding the best subsequence. If there is an optimal alignment from F(0, 0)
        to F(m, n) (or the optimal alignment across both substrings), then this means that there is an optimal alignment
        between F(0, 0) to F(i, j) and F(i+1, j+1) and F(m, n) for any i in [0, m) and j in [0, n). This shows that
        every subpath in an optimal path has to also be optimal.
      </p>
      <h1 class="
      mb-2
      text-lg
      font-extrabold
      leading-snug
      tracking-tight
      text-gray-800
      md:text-lg
      text-gray-900
      hover:text-purple-700
      my-5
    ">
        Filling the Matrix -
      </h1>
      <img src="https://miro.medium.com/max/768/1*x9FhuHbopwjkwbT11RJo6g.png" class="mx-auto my-5">

      <p class="mb-4 text-base font-normal text-gray-600">
        The first step is to initialize some rows and columns so that the algorithm can systematically fill data into
        other cells in the matrix. F(0, 0) is initialized with 0, because no alignments have been made yet. F(i, 0) =
        F(i-1, 0)-d, because a state change from F(i-1, 0) to F(i, 0) means that Sequence T had a gap, which contributes
        to a gap error penalty. Similarly, F(0, j) = F(0, j-1)-d, because a state change from F(0, j-1) to F(0, j) means
        that Sequence S had a gap.
      </p>

      <pre class="mb-4 text-base font-normal text-gray-900">
The next step is to fill the matrix F with optimal scores. At each spot F(i, j), there are four possibilities that need to be considered:

        Sequence S has a gap at the current alignment: F(i, j-1)
        Sequence T has a gap at the current alignment: F(i-1, j)
        There is a nucleotide substitution at the current position: F (i-1, j-1)
      </pre>
      <p class="mb-4 text-base font-normal text-gray-600">
        Each of these scenarios provide different scores. To maximize our final score and reduce our cost, we have to
        take the maximum from these scenarios.
        There is a match at the current position: F(i-1, j-1)
      </p>

      <h1 class="
      mb-2
      text-lg
      font-extrabold
      leading-snug
      tracking-tight
      text-gray-800
      md:text-lg
      text-gray-900
      hover:text-purple-700
      my-5
    ">
        Traceback
      </h1>
      <p class="mb-4 text-base font-normal text-gray-600">
        After initializing the matrix, the final step is to traceback through the matrix starting at the bottom right
        until you get to the top left (or from F(m, n) to F(0, 0)). This will provide the optimal alignment, and
        determining what the path means will give you the longest common substring.
      </p>
      <img src="https://miro.medium.com/max/540/0*X2Q72Oil8tYPwt0q.png" class="mx-auto my-5" alt="">


      <h1 class="
      mb-2
      text-lg
      font-extrabold
      leading-snug
      tracking-tight
      text-gray-800
      md:text-lg
      text-gray-900
      hover:text-purple-700
      my-5
    ">
        Conclusion
      </h1>
      <p class="mb-4 text-base font-normal text-gray-600">
      <ul class="list-disc mb-4 text-base font-normal text-gray-600">
        <li class="my-2">Sequence alignment allows us to compare two genetic strands and determine what mutations led one to another.
        </li>
        <li class="my-2">During sequence alignments, certain costs have to be placed on gap sizes and different nucleotide
          alterations so that the sequence alignment makes more sense probabilistically and biologically.
        </li>
        <li class="my-2">The most simplistic sequence alignment algorithm, the most common substring, has the least accuracy but one
          of the fastest runtimes (quadratic). The most common subsequence has a higher accuracy but an extremely slow
          runtime (exponential).
        </li class="my-2">
        <li class="my-2">Dynamic programming allows us to use repeating optimal subsequences to reduce the computation runtime of the
          model. The Needleman-Wunsch algorithm creates a matrix of scores for each subalignment, and finds the optimal
          alignment by tracing back through the maximum scores. The time and space complexity for this algorithm is
          quadratic.
        </li>
        <li class="my-2">Optimizations, such as bounded space programing and linear space alignment, exist to make the runtime
          linear.
        </li>
        <li class="my-2">The Needleman-Wunsch algorithm can be extended to sequence alignment for multiple sequences.
        </li>
        <li class="my-2">Instead of matching whole sequences together, certain sections of the sequences can be matched together to
          increase accuracy of the model and provide a better view of the evolutionary pathway between the two sequences
          provided.
        </li>
      </ul>
      </p>



    </div>
  </div>

  <!-- Content Ends -->

  <!-- Footer starts -->

  <footer class="bg-white" aria-labelledby="footer-heading">
    <h2 id="footer-heading" class="sr-only">Footer</h2>
    <div class="px-4 py-12 mx-auto bg-gray-50 max-w-7xl sm:px-6 lg:px-16">
      <div class="flex flex-wrap items-baseline lg:justify-center">
        <span class="mt-2 text-sm font-light text-gray-500">
          Copyright © 2020 - 2021
          <a href="/" class="mx-2 text-wickedblue hover:text-gray-500" rel="noopener noreferrer">@AlignIt</a>. Since
          2021
        </span>
      </div>
    </div>
  </footer>

  <!-- Footer Ends -->

  <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
  <script>
    AOS.init();
  </script>
</body>

</html>